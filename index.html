<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Pile ou Face 3D</title>
<style>
  :root { color-scheme: dark; }
  * { margin: 0; padding: 0; box-sizing: border-box; }

  html, body {
    height: 100%;
  }

  body {
    background: #000;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    color: #fff;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .app {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100vh;
  }

  .scene-wrapper {
    flex: 1;
    position: relative;
  }

  canvas {
  display: block;
  width: 100%;
  height: 100%;
  touch-action: none;
  background: #000;
  user-select: none;            /* ← ajouté */
  -webkit-user-select: none;    /* ← ajouté */
  -webkit-touch-callout: none;  /* ← ajouté */
}

  .ui {
    background: #000;
    padding: 10px 12px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
    text-align: center;
  }

  #result {
    font-size: 1.2rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    opacity: 0.9;
  }

  .hint {
    margin-top: 2px;
    opacity: 0.6;
    font-size: 0.75rem;
  }

  @media (min-width: 768px) {
    body {
      justify-content: center;
      align-items: center;
      background: #000;
    }

    .app {
      max-width: 480px;
      max-height: 820px;
      overflow: hidden;
    }

    #result {
      font-size: 1.4rem;
    }
  }
</style>
</head>
<body>

<div class="app">
  <div class="scene-wrapper" id="sceneWrapper"></div>
  <div class="ui">
    <div id="result">Swipe vers le haut pour lancer</div>

  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>

<script>
// =========================
//   SCÈNE, CAMÉRA, RENDER
// =========================
const wrapper = document.getElementById("sceneWrapper");
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  60,
  wrapper.clientWidth / wrapper.clientHeight,
  0.1,
  100
);
camera.position.set(0, 2.0, 4.2);
camera.lookAt(0, 1.6, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
wrapper.appendChild(renderer.domElement);

// =========================
//        AUDIO
// =========================
const flipSound = new Audio("flip.ogg");
flipSound.preload = "auto";
flipSound.volume = 0.1;

// =========================
//        LUMIÈRES
// =========================
// Lumière principale qui vient d'au-dessus et légèrement côté caméra
const dirLight = new THREE.DirectionalLight(0xffffff, 1.4);
dirLight.position.set(0, 5, 3); // au-dessus, légèrement vers la caméra
scene.add(dirLight);

// Lumière d'ambiance un peu plus faible pour garder du contraste
const ambientLight = new THREE.AmbientLight(0xffffff, 10);
scene.add(ambientLight);


// =========================
//       PIÈCE 3D (textures)
// =========================
const coinRadius = 0.6;
const coinThickness = 0.06;
const coinGeometry = new THREE.CylinderGeometry(coinRadius, coinRadius, coinThickness, 64);

const loader = new THREE.TextureLoader();

// textures
const pileTexture = loader.load("img/pile.png"); // PILE = cap +Y
const faceTexture = loader.load("img/face.png"); // FACE = cap -Y

// couleur de base de toute la pièce
const baseColor = 0xAB8137;

// Matériau PILE (cap +Y)
const pileMaterial = new THREE.MeshStandardMaterial({
  map: pileTexture,
  color: baseColor,
  metalness: 0.85,
  roughness: 0.25
});

// Matériau FACE (cap -Y)
const faceMaterial = new THREE.MeshStandardMaterial({
  map: faceTexture,
  color: baseColor,
  metalness: 0.85,
  roughness: 0.35
});

// Matériau tranche
const edgeMaterial = new THREE.MeshStandardMaterial({
  color: baseColor,
  metalness: 0.8,
  roughness: 0.4
});

// IMPORTANT pour CylinderGeometry :
// 0 = tranche
// 1 = cap +Y (haut)  -> PILE
// 2 = cap -Y (bas)   -> FACE
const coin = new THREE.Mesh(coinGeometry, [
  edgeMaterial, // tranche
  pileMaterial, // +Y -> PILE
  faceMaterial  // -Y -> FACE
]);
scene.add(coin);

// Position basse
const gap = 0.04;
const baseHeight = (coinThickness / 2) + gap;
coin.position.y = baseHeight;
coin.rotation.set(0, 0, 0);

// =========================
//   VARIABLES D'ANIMATION
// =========================
const clock = new THREE.Clock();
let isFlipping = false;
let flipStart = 0;
let flipDuration = 1.0;
let spins = 3;

let resultIsPile = true;  // true = PILE, false = FACE
let targetRotationX = 0;  // rotation finale (incl. tours + face)

let wobble = false;
let wobbleStart = 0;
// oscille longtemps
const wobbleDuration = 1.2;
let finalAngleX = 0;

// hauteur
const maxHeight = 2.6;

const resultDiv = document.getElementById("result");

function easeOutCubic(t) {
  return 1 - Math.pow(1 - t, 3);
}

// =========================
//         ANIMATION
// =========================
function animate() {
  requestAnimationFrame(animate);

  const t = clock.getElapsedTime();

  if (isFlipping) {
    const elapsed = t - flipStart;
    const p = Math.min(elapsed / flipDuration, 1);

    // Trajectoire verticale (parabole) : 0 -> haut -> 0
    const hNorm = 4 * p * (1 - p);
    coin.position.y = baseHeight + hNorm * maxHeight;

    // Rotation avec easing : part de 0 et va jusqu'à targetRotationX
    const ease = easeOutCubic(p);
    coin.rotation.x = targetRotationX * ease;

    // légère rotation autour de Y pour l'effet
    coin.rotation.y = (spins * 2 * Math.PI * 0.25) * ease;

    if (p >= 1) {
      // Fin de la phase de flip
      isFlipping = false;
      coin.position.y = baseHeight;

      // angle final exact (PILE = 0, FACE = π)
      finalAngleX = resultIsPile ? 0 : Math.PI;
      coin.rotation.x = finalAngleX;

      // démarrage de l'oscillation (wobble)
      wobble = true;
      wobbleStart = t;
      resultDiv.textContent = resultIsPile ? "PILE !" : "FACE !";
    }
  } else if (wobble) {
    const dt = t - wobbleStart;

    if (dt < wobbleDuration) {
      const progress = dt / wobbleDuration;
      const decay = 1 - progress; // amplitude qui diminue

      // Oscillation plus marquée : amplitude plus grande, fréquence un peu ajustée
      const wobbleAngle = Math.sin(dt * 20) * 0.08 * decay;
      coin.position.y = baseHeight;
      coin.rotation.x = finalAngleX + wobbleAngle;
    } else {
      wobble = false;
      coin.position.y = baseHeight;
      coin.rotation.x = finalAngleX;
    }
  }

  renderer.render(scene, camera);
}
animate();

// =========================
//         LANCER
// =========================
function launch() {
  if (isFlipping || wobble) return;

  isFlipping = true;
  wobble = false;

  // la pièce retombe un chouilla plus tôt
  flipDuration = 0.8 + Math.random() * 0.25; // ~0.8–1.05s

  // tours complets (2 à 4 tours)
  spins = 2 + Math.floor(Math.random() * 3);

  // résultat aléatoire
  resultIsPile = Math.random() < 0.5;

  // reset orientation et position de départ
  coin.rotation.set(0, 0, 0);
  coin.position.y = baseHeight;

  // rotation finale = tours complets + orientation de la face
  const baseAngle = resultIsPile ? 0 : Math.PI;
  targetRotationX = baseAngle + spins * 2 * Math.PI;

  // Jouer le son du flip (geste utilisateur)
  try {
    flipSound.currentTime = 0;
    flipSound.play();
  } catch (e) {
    // certains navigateurs peuvent bloquer, on ignore
  }

  flipStart = clock.getElapsedTime();
  resultDiv.textContent = "La pièce tourne...";
}

// =========================
//   GESTE : SWIPE VERS LE HAUT (mobile)
// =========================
let touchStartX = 0;
let touchStartY = 0;
let touchStartTime = 0;

const SWIPE_MIN_DISTANCE = 40;   // px
const SWIPE_MAX_DURATION = 800;  // ms

wrapper.addEventListener("touchstart", (e) => {
  const touch = e.changedTouches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
  touchStartTime = performance.now();
}, { passive: true });

wrapper.addEventListener("touchend", (e) => {
  const touch = e.changedTouches[0];
  const dx = touch.clientX - touchStartX;
  const dy = touch.clientY - touchStartY;
  const dt = performance.now() - touchStartTime;

  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);

  // Swipe vers le haut = mouvement vertical dominant, vers le haut, assez rapide
  if (
    dt <= SWIPE_MAX_DURATION &&
    absDy > absDx &&
    (touchStartY - touch.clientY) > SWIPE_MIN_DISTANCE
  ) {
    launch();
  }
}, { passive: true });

// =========================
//   CLIC (desktop)
// =========================
document.addEventListener("click", () => {
  if (matchMedia("(pointer: fine)").matches) {
    launch();
  }
});

// =========================
//        RESPONSIVE
// =========================
function onResize() {
  const w = wrapper.clientWidth;
  const h = wrapper.clientHeight;

  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
}
window.addEventListener("resize", onResize);
window.addEventListener("orientationchange", () => setTimeout(onResize, 250));
onResize();
</script>

</body>
</html>
